#!/usr/bin/env python3
"""
Système de détection d'imprimantes automatique pour photovinc
- Détection des imprimantes disponibles via CUPS
- Configuration automatique compatible
- Support multi-imprimantes
- Fallback sur mode démo si aucune imprimante
"""

import subprocess
import logging
import shutil
import os
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
import json
from dataclasses import dataclass, asdict

logger = logging.getLogger(__name__)


@dataclass
class PrinterInfo:
    """Information sur une imprimante détectée"""
    name: str
    model: str
    status: str
    device_uri: str
    is_default: bool = False
    is_available: bool = True
    location: str = ""
    paper_size: str = "Postcard"
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


class PrinterDetector:
    """Détecte et analyse les imprimantes disponibles"""
    
    def __init__(self):
        self.printers: Dict[str, PrinterInfo] = {}
        self.cache_file = Path.home() / ".photovinc_printers_cache.json"
        self.lpstat_path = self._find_lpstat()
        self.cups_available = self._check_cups()
    
    def _find_lpstat(self) -> str:
        """Trouve le chemin de lpstat de manière exhaustive"""
        # Liste de chemins possibles
        possible_paths = [
            '/usr/bin/lpstat',
            '/bin/lpstat',
            '/usr/local/bin/lpstat',
            shutil.which('lpstat')
        ]
        
        for path in possible_paths:
            if path and Path(path).exists():
                logger.info(f"lpstat trouvé: {path}")
                return path
        
        logger.error("lpstat introuvable dans les chemins standards")
        return '/usr/bin/lpstat'  # Fallback
    
    def _check_cups(self) -> bool:
        """Vérifie si CUPS est disponible"""
        if not Path(self.lpstat_path).exists():
            logger.warning(f"lpstat non trouvé: {self.lpstat_path}")
            return False
        
        # Vérifier les permissions
        if not os.access(self.lpstat_path, os.X_OK):
            logger.warning(f"lpstat non exécutable: {self.lpstat_path}")
            return False
        
        try:
            # Ajouter /usr/bin au PATH si nécessaire
            env = os.environ.copy()
            if '/usr/bin' not in env.get('PATH', ''):
                env['PATH'] = f"/usr/bin:/bin:{env.get('PATH', '')}"
            
            result = subprocess.run(
                [self.lpstat_path, '--version'],
                capture_output=True,
                timeout=2,
                env=env
            )
            
            if result.returncode == 0:
                logger.info("CUPS disponible")
                return True
            else:
                logger.warning(f"lpstat erreur: {result.stderr.decode()}")
                return False
                
        except FileNotFoundError as e:
            logger.error(f"Fichier non trouvé: {e}")
            return False
        except Exception as e:
            logger.error(f"CUPS non disponible: {e}")
            return False
    
    def detect_printers(self) -> Dict[str, PrinterInfo]:
        """Détecte toutes les imprimantes disponibles"""
        self.printers.clear()
        
        if not self.cups_available:
            logger.warning("Impossible de détecter les imprimantes (CUPS indisponible)")
            return {}
        
        try:
            # Préparer l'environnement
            env = os.environ.copy()
            if '/usr/bin' not in env.get('PATH', ''):
                env['PATH'] = f"/usr/bin:/bin:{env.get('PATH', '')}"
            
            # Obtenir la liste des imprimantes
            logger.info(f"Exécution: {self.lpstat_path} -p -d")
            result = subprocess.run(
                [self.lpstat_path, '-p', '-d'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env
            )
            
            logger.info(f"Return code: {result.returncode}")
            logger.info(f"Stdout: {result.stdout}")
            logger.info(f"Stderr: {result.stderr}")
            
            if result.returncode != 0:
                logger.warning(f"lpstat erreur: {result.stderr}")
                return {}
            
            if not result.stdout.strip():
                logger.warning("Aucune sortie de lpstat")
                return {}
            
            lines = result.stdout.strip().split('\n')
            default_printer = None
            
            # Parser la sortie
            for line in lines:
                logger.debug(f"Parse ligne: {line}")
                
                if 'device for' in line.lower() or 'system default destination' in line.lower():
                    # Ligne du type: device for Canon_CP400: /dev/usb/printer0
                    # ou: system default destination: CP_400
                    parts = line.split(':')
                    if len(parts) >= 2:
                        default_printer = parts[-1].strip()
                        logger.info(f"Imprimante par défaut: {default_printer}")
                
                elif line.startswith('printer'):
                    # Ligne du type: printer Canon_CP400 is idle
                    printer_info = self._parse_printer_line(line)
                    if printer_info:
                        is_default = printer_info.name == default_printer
                        printer_info.is_default = is_default
                        self.printers[printer_info.name] = printer_info
                        logger.info(f"Imprimante ajoutée: {printer_info.name}")
            
            if self.printers:
                logger.info(f"Détection réussie: {len(self.printers)} imprimante(s)")
                for name, info in self.printers.items():
                    logger.info(f"  - {name}: {info.status}")
            else:
                logger.warning("Aucune imprimante trouvée dans la sortie lpstat")
            
            return self.printers
            
        except subprocess.TimeoutExpired:
            logger.error("Timeout lors de la détection des imprimantes")
            return {}
        except Exception as e:
            logger.error(f"Erreur détection imprimantes: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return {}
    
    def _parse_printer_line(self, line: str) -> Optional[PrinterInfo]:
        """Parse une ligne lpstat pour extraire les infos imprimante"""
        try:
            # Format: printer NAME is STATE
            parts = line.split()
            if len(parts) < 4:
                return None
            
            name = parts[1]
            status = ' '.join(parts[3:]) if len(parts) > 3 else 'unknown'
            
            # Obtenir les détails de l'imprimante
            device_uri = self._get_printer_device_uri(name)
            model = self._detect_printer_model(name, device_uri)
            
            return PrinterInfo(
                name=name,
                model=model,
                status=status,
                device_uri=device_uri,
                is_available=status.lower().replace('.', '') in ['idle', 'processing']
            )
        except Exception as e:
            logger.error(f"Erreur parsing ligne '{line}': {e}")
            return None
    
    def _get_printer_device_uri(self, printer_name: str) -> str:
        """Obtient l'URI du périphérique pour une imprimante"""
        try:
            env = os.environ.copy()
            if '/usr/bin' not in env.get('PATH', ''):
                env['PATH'] = f"/usr/bin:/bin:{env.get('PATH', '')}"
            
            result = subprocess.run(
                [self.lpstat_path, '-l', '-p', printer_name],
                capture_output=True,
                text=True,
                timeout=3,
                env=env
            )
            
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'device for' in line.lower() or 'interface' in line.lower():
                        parts = line.split(':')
                        if len(parts) >= 2:
                            return ':'.join(parts[1:]).strip()
            
            return "unknown"
        except Exception as e:
            logger.error(f"Erreur récupération URI: {e}")
            return "unknown"
    
    def _detect_printer_model(self, printer_name: str, device_uri: str) -> str:
        """Détecte le modèle d'imprimante"""
        # Mapping connu
        known_models = {
            'CP': 'Canon CP-400',
            'CP400': 'Canon CP-400',
            'CP_400': 'Canon CP-400',
            'CP910': 'Canon CP-910',
            'SELPHY': 'Canon SELPHY',
            'DPP': 'Canon DPP',
            'Nikon': 'Nikon',
            'Canon': 'Canon',
            'Epson': 'Epson',
            'EPSON': 'Epson',
            'Stylus': 'Epson Stylus',
            'R360': 'Epson R360',
            'HP': 'HP',
            'Brother': 'Brother',
            'Xerox': 'Xerox'
        }
        
        # Chercher dans le nom et l'URI
        search_text = f"{printer_name} {device_uri}".upper()
        
        for key, model in known_models.items():
            if key.upper() in search_text:
                return model
        
        return f"Imprimante ({printer_name})"
    
    def get_best_printer(self) -> Optional[PrinterInfo]:
        """Retourne l'imprimante la plus appropriée"""
        if not self.printers:
            return None
        
        # Priorité: imprimante par défaut, puis première disponible
        for info in self.printers.values():
            if info.is_default and info.is_available:
                return info
        
        for info in self.printers.values():
            if info.is_available:
                return info
        
        return list(self.printers.values())[0]
    
    def cache_printers(self):
        """Sauvegarde les imprimantes détectées en cache"""
        try:
            data = {name: info.to_dict() for name, info in self.printers.items()}
            with open(self.cache_file, 'w') as f:
                json.dump(data, f, indent=2)
            logger.info(f"Cache imprimantes sauvegardé: {self.cache_file}")
        except Exception as e:
            logger.error(f"Erreur sauvegarde cache: {e}")
    
    def load_cached_printers(self) -> Dict[str, PrinterInfo]:
        """Charge les imprimantes depuis le cache"""
        try:
            if self.cache_file.exists():
                with open(self.cache_file, 'r') as f:
                    data = json.load(f)
                    self.printers = {
                        name: PrinterInfo(**info) 
                        for name, info in data.items()
                    }
                logger.info(f"Imprimantes chargées depuis le cache")
                return self.printers
        except Exception as e:
            logger.error(f"Erreur lecture cache: {e}")
        
        return {}


class PrinterCompatibilityManager:
    """Gère la compatibilité des imprimantes avec photovinc"""
    
    # Profiles de compatibilité par modèle
    PRINTER_PROFILES = {
        'Canon CP-400': {
            'paper_size': 'Postcard',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 101,
            'max_height': 152,
            'driver': 'lpadmin -p {name} -E -v {uri} -m drv:///sample.drv/generic.ppd'
        },
        'Canon CP-910': {
            'paper_size': 'Postcard',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 101,
            'max_height': 152,
            'driver': 'lpadmin'
        },
        'Canon SELPHY': {
            'paper_size': 'Postcard',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 101,
            'max_height': 152,
            'driver': 'lpadmin'
        },
        'Canon': {
            'paper_size': 'A4',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 210,
            'max_height': 297,
            'driver': 'lpadmin'
        },
        'Epson': {
            'paper_size': 'A4',
            'dpi': 360,
            'color_mode': 'RGB',
            'max_width': 210,
            'max_height': 297,
            'driver': 'lpadmin'
        },
        'Epson Stylus': {
            'paper_size': 'A4',
            'dpi': 360,
            'color_mode': 'RGB',
            'max_width': 210,
            'max_height': 297,
            'driver': 'lpadmin'
        },
        'Epson R360': {
            'paper_size': 'Postcard',
            'dpi': 360,
            'color_mode': 'RGB',
            'max_width': 101,
            'max_height': 152,
            'driver': 'lpadmin'
        },
        'HP': {
            'paper_size': 'A4',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 210,
            'max_height': 297,
            'driver': 'lpadmin'
        },
        'Brother': {
            'paper_size': 'A4',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 210,
            'max_height': 297,
            'driver': 'lpadmin'
        }
    }
    
    @staticmethod
    def get_profile(model: str) -> Dict[str, Any]:
        """Obtient le profile de compatibilité pour un modèle"""
        # Chercher un match exact
        if model in PrinterCompatibilityManager.PRINTER_PROFILES:
            return PrinterCompatibilityManager.PRINTER_PROFILES[model]
        
        # Chercher un match partiel
        for key, profile in PrinterCompatibilityManager.PRINTER_PROFILES.items():
            if key.lower() in model.lower() or model.lower() in key.lower():
                return profile
        
        # Profile par défaut générique
        return {
            'paper_size': 'A4',
            'dpi': 300,
            'color_mode': 'RGB',
            'max_width': 210,
            'max_height': 297,
            'driver': 'lpadmin'
        }
    
    @staticmethod
    def check_paper_size_compatibility(printer_model: str, paper_size: str) -> bool:
        """Vérifie la compatibilité du format de papier"""
        profile = PrinterCompatibilityManager.get_profile(printer_model)
        
        # Format connu pour cette imprimante?
        max_width = profile.get('max_width', 210)
        max_height = profile.get('max_height', 297)
        
        # Vérifier les dimensions
        if paper_size.lower() == 'postcard':
            return max_width >= 101 and max_height >= 152
        elif paper_size.lower() == 'a4':
            return max_width >= 210 and max_height >= 297
        elif paper_size.lower() == 'a5':
            return max_width >= 148 and max_height >= 210
        
        return True  # Format inconnu, on suppose compatible


class PrinterIntegration:
    """Intègre les imprimantes détectées au système photovinc"""
    
    def __init__(self, plugin_manager):
        self.manager = plugin_manager
        self.detector = PrinterDetector()
        self.compatibility = PrinterCompatibilityManager()
        self.selected_printer: Optional[PrinterInfo] = None
    
    def initialize(self) -> Tuple[bool, str]:
        """Initialise la détection et l'intégration des imprimantes"""
        logger.info("Initialisation système de détection d'imprimantes")
        
        # Tenter la détection
        printers = self.detector.detect_printers()
        
        if not printers:
            # Essayer le cache
            printers = self.detector.load_cached_printers()
            if not printers:
                logger.warning("Aucune imprimante détectée, mode démo sera utilisé")
                return False, "Aucune imprimante détectée"
        
        # Sauvegarder en cache
        self.detector.cache_printers()
        
        # Sélectionner la meilleure imprimante
        self.selected_printer = self.detector.get_best_printer()
        
        if not self.selected_printer:
            return False, "Impossible de sélectionner une imprimante"
        
        # Configurer le plugin printer avec cette imprimante
        self._configure_printer_plugin()
        
        msg = f"Imprimante détectée: {self.selected_printer.name} ({self.selected_printer.model})"
        logger.info(msg)
        return True, msg
    
    def _configure_printer_plugin(self):
        """Configure le plugin printer avec l'imprimante détectée"""
        if not self.selected_printer:
            return
        
        # Obtenir le profile de compatibilité
        profile = self.compatibility.get_profile(self.selected_printer.model)
        
        # Mettre à jour la configuration du plugin
        printer_config = self.manager.plugin_configs.get('printer')
        if printer_config:
            printer_config.settings.update({
                'printer_name': self.selected_printer.name,
                'printer_model': self.selected_printer.model,
                'device_uri': self.selected_printer.device_uri,
                'paper_size': profile.get('paper_size', 'Postcard'),
                'dpi': profile.get('dpi', 300),
                'max_width': profile.get('max_width', 101),
                'max_height': profile.get('max_height', 152),
                'compatible': True
            })
            
            self.manager.save_config()
            logger.info(f"Plugin printer configuré pour {self.selected_printer.name}")
    
    def get_printer_info(self) -> Dict[str, Any]:
        """Retourne les informations sur l'imprimante sélectionnée"""
        if not self.selected_printer:
            return {}
        
        return {
            'name': self.selected_printer.name,
            'model': self.selected_printer.model,
            'status': self.selected_printer.status,
            'device_uri': self.selected_printer.device_uri,
            'is_default': self.selected_printer.is_default,
            'is_available': self.selected_printer.is_available,
            'profile': self.compatibility.get_profile(self.selected_printer.model)
        }
    
    def get_all_printers(self) -> List[Dict[str, Any]]:
        """Retourne la liste de toutes les imprimantes détectées"""
        return [info.to_dict() for info in self.detector.printers.values()]
    
    def select_printer(self, printer_name: str) -> bool:
        """Sélectionne une imprimante spécifique"""
        if printer_name not in self.detector.printers:
            logger.error(f"Imprimante non trouvée: {printer_name}")
            return False
        
        self.selected_printer = self.detector.printers[printer_name]
        self._configure_printer_plugin()
        logger.info(f"Imprimante sélectionnée: {printer_name}")
        return True


# Fonction d'intégration minimale pour integration_complete.py
def setup_printer_detection(plugin_manager) -> Tuple[bool, str]:
    """
    À appeler au démarrage de photovincAppComplete
    Retourne (succès, message)
    """
    integration = PrinterIntegration(plugin_manager)
    return integration.initialize()


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(levelname)s:%(name)s:%(message)s'
    )
    
    # Test du système
    print("\n=== Diagnostic lpstat ===")
    detector = PrinterDetector()
    print(f"Chemin lpstat: {detector.lpstat_path}")
    print(f"Existe: {Path(detector.lpstat_path).exists()}")
    print(f"Exécutable: {os.access(detector.lpstat_path, os.X_OK)}")
    print(f"CUPS disponible: {detector.cups_available}")
    
    print("\n=== Détection Imprimantes ===")
    printers = detector.detect_printers()
    
    if printers:
        for name, info in printers.items():
            print(f"✓ {info.model} ({name})")
            print(f"  Status: {info.status}")
            print(f"  URI: {info.device_uri}")
            print(f"  Default: {'Oui' if info.is_default else 'Non'}")
            print()
    else:
        print("✗ Aucune imprimante détectée")
    
    # Test compatibilité
    print("\n=== Profils Compatibilité ===")
    for model in ['Canon CP-400', 'Epson', 'HP']:
        profile = PrinterCompatibilityManager.get_profile(model)
        print(f"{model}: {profile['paper_size']} @ {profile['dpi']} DPI")
